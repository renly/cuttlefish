Automatically generated by Mendeley Desktop 1.16.3
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Preferences -> BibTeX in Mendeley Desktop

@article{Vigna2016,
author = {Vigna, Giovanni},
doi = {10.1145/2897845.2901788},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/p473-vigna.pdf:pdf},
isbn = {978-1-4503-4233-9},
journal = {AsiaCCS},
pages = {473},
title = {{Binary Analysis for Autonomous Hacking: Invited Abstract.}},
url = {http://dblp.uni-trier.de/db/conf/ccs/asiaccs2016.html{\#}Vigna16},
year = {2016}
}
@article{Hanov2003,
abstract = {This paper is a survey of the use of static program analysis techniques on binary executables. Static analysis techniques are often used on a program's source code, which is usually a high level language. It is possible to apply them directly on the machine code of a compiled program. One of the challenges is building up a control ﬂow graph of a procedure, since indirect branch instructions accept the contents of a register for the destination address. Program slicing techniques can be used to reduce the assembly code to the smallest possible program to compute the value of that register, and determine the range of values in the register. Another problem is disassembly itself. On architectures with instructions of varying size, it is diﬃcult to locate the start of the ﬁrst machine code instruction in a section consisting of both code and data. Also, malicious code could take advantage of the diﬃculties in disassembly to hide its existence. Various static analysis techniques have been developed to analyze such programs, in order to build up a control ﬂow graph and a call graph. Finally, type-state techniques have been developed to verify that machine code conforms to its interface, and does not alter areas of memory which it should not.},
author = {Hanov, Steve},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/final{\_}for{\_}notes/cs842{\_}project.pdf:pdf},
journal = {Stevehanov.Ca},
title = {{Static Analysis of Binary Executables}},
url = {http://stevehanov.ca/cs842{\_}project.pdf},
year = {2003}
}
@article{Bjorner2011,
abstract = {Constraint-satisfaction problems arise in diverse application areas, including software and hardware verification, type inference, static program analysis, test-case generation, scheduling, planning, and graph problems, and share a common trait—a core component using logical formulas for describing},
author = {Bjorner, Nikolaj and Moura, Leonardo De},
doi = {10.1145/1995376},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/p69-de{\_}moura.pdf:pdf},
isbn = {9781586039295},
issn = {00010782},
journal = {Commun. ACM},
keywords = {background},
mendeley-tags = {background},
pages = {69--77},
title = {{Satisfiability Modulo Theories: Introduction and Applications}},
year = {2011}
}
@article{ThanassisAvgerinosSangKilCha2012,
author = {{Thanassis Avgerinos, Sang Kil Cha}, Brent Lim Tze Hao and David Brumley},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/aeg-current.pdf:pdf},
keywords = {Mayhem},
mendeley-tags = {Mayhem},
title = {{Automatic Exploit Generation (AEG)}},
year = {2012}
}
@misc{AFL,
author = {AFL},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/http-lcamtuf.coredump.cxafltechnical{\_}details.txt.pdf:pdf},
title = {{Technical "whitepaper" for afl-fuzz}}
}
@article{Schwartz2010,
author = {Schwartz, Edward J and Avgerinos, Thanassis and Brumley, David and Schwartz, Edward J and Avgerinos, Thanassis and Brumley, David},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/https-users.ece.cmu.edu-aavgerinpapersOakland10.pdf.pdf:pdf},
keywords = {-taint},
pages = {1--5},
title = {{All You Ever Wanted to Know About Dynamic Taint Analysis Forward Symbolic Execution ( but might have been afraid to ask ) A Few Things You Need to Know About Dynamic Taint Analysis Forward Symbolic Execution ( but might have been afraid to ask ) The Root}},
year = {2010}
}
@article{Hu2006,
abstract = {One of the most common forms of security attacks involves exploiting a vulnerability to inject malicious code into an executing application and then cause the injected code to be executed. A theoretically strong approach to defending against any type of code-injection attack is to create and use a process-specific instruction set that is created by a randomization algorithm. Code injected by an attacker who does not know the randomization key will be invalid for the randomized processor effectively thwarting the attack. This paper describes a secure and efficient implementation of instruction-set randomization (ISR) using software dynamic translation. The paper makes three contributions beyond previous work on ISR. First, we describe an implementation that uses a strong cipher algorithm-the Advanced Encryption Standard (AES), to perform randomization. AES is generally believed to be impervious to known attack methodologies. Second, we demonstrate that ISR using AES can be implemented practically and efficiently (considering both execution time and code size overheads) without requiring special hardware support. The third contribution is that our approach detects malicious code before it is executed. Previous approaches relied on probabilistic arguments that execution of non-randomized foreign code would eventually cause a fault or runtime exception.},
author = {Hu, Wei and Hiser, Jason and Williams, Dan and Filipi, Adrian and Davidson, Jack W and Evans, David and Knight, John C and Nguyen-Tuong, Anh and Rowanhill, Jonathan},
doi = {10.1145/1134760.1134764},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/p2-hu.pdf:pdf},
isbn = {1595933328},
journal = {Proc. 2nd Int. Conf. Virtual Exec. Environ. - VEE '06},
keywords = {software dynamic transla,virtual execution},
pages = {2},
title = {{Secure and practical defense against code-injection attacks using software dynamic translation}},
url = {http://portal.acm.org/citation.cfm?doid=1134760.1134764$\backslash$nhttp://dl.acm.org/citation.cfm?doid=1134760.1134764},
year = {2006}
}
@article{Shoshitaishvili,
author = {Shoshitaishvili, Yan and Wang, Ruoyu and Salls, Christopher and Stephens, Nick and Polino, Mario and Dutcher, Andrew and Grosen, John and Feng, Siji and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/2016{\_}SP{\_}angrSoK.pdf:pdf},
keywords = {Mechanical Phish},
mendeley-tags = {Mechanical Phish},
title = {{[ANGR-SP16] (State of) The Art of War: Offensive Techniques in Binary Analysis}}
}
@article{Nethercote2004,
abstract = {Dynamic binary analysis (DBA) tools such as prolers and checkers help programmers create better software. Dynamic binary instrumentation (DBI) frameworks make it easy to build new DBA tools. This dissertation advances the theory and practice of dynamic binary analysis and instrumentation, with an emphasis on the importance of the use and support of metadata. The dissertation has three main parts. The first part describes a DBI framework called Valgrind which provides novel features to support heavyweight DBA tools that maintain rich metadata, especially location metadatathe shadowing of every register and memory location with a metavalue. Location metadata is used in shadow computation, a kind of DBA where every normal operation is shadowed by an abstract operation. The second part describes three powerful DBA tools. The rst tool performs detailed cache profiling. The second tool does an old kind of dynamic analysisbounds-checkingin a new way. The third tool produces dynamic data flow graphs, a novel visualisation that cuts to the essence of a program's execution. All three tools were built with Valgrind, and rely on Valgrind's support for heavyweight DBA and rich metadata, and the latter two perform shadow computation. The third part describes a novel system of semi-formal descriptions of DBA tools. It gives many example descriptions, and also considers in detail exactly what dynamic analysis is. The dissertation makes six main contributions. First, the descriptions show that metadata is the key component of dynamic analysis; in particular, whereas static analysis predicts approximations of a program's future, dynamic analysis remembers approximations of a program's past, and these approximations are exactly what metadata is. Second, the example tools show that rich metadata and shadow computation make for powerful and novel DBA tools that do more than the traditional tracing and profiling. Third, Valgrind and the example tools show that a DBI framework can make it easy to build heavyweight DBA tools, by providing good support for rich metadata and shadow computation. Fourth, the descriptions are a precise and concise way of characterising tools, provide a directed way of thinking about tools that can lead to better implementations, and indicate the theoretical upper limit of the power of DBA tools in general. Fifth, the three example tools are interesting in their own right, and the latter two are novel. Finally, the entire dissertation provides many details, and represents a great deal of condensed experience, about implementing DBI frameworks and DBA tools.},
author = {Nethercote, Nicholas},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/phd2004.pdf:pdf},
journal = {Environments},
keywords = {Valgrind,background},
mendeley-tags = {background},
title = {{Dynamic Binary Analysis and Instrumentation or Building Tools is Easy}},
year = {2004}
}
@article{Scott2003,
abstract = { Software dynamic translation (SDT) is a technology that permits the modification of an executing program's instructions. In recent years, SDT has received increased attention, from both industry and academia, as a feasible and effective approach to solving a variety of significant problems. Despite this increased attention, the task of initiating a new project in software dynamic translation remains a difficult one. To address this concern, and in particular, to promote the adoption of SDT technology into an even wider range of applications, we have implemented Strata, a cross-platform infrastructure for building software dynamic translators. This paper describes Strata's architecture, our experience retargeting it to three different processors, and our use of Strata to build two novel SDT systems - one for safe execution of untrusted binaries and one for fast prototyping of architectural simulators.},
author = {Scott, K. and Kumar, N. and Velusamy, S. and Childers, B. and Davidson, J. W. and Soffa, M. L.},
doi = {10.1109/CGO.2003.1191531},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/cgo03.pdf:pdf},
isbn = {076951913X},
journal = {Int. Symp. Code Gener. Optim. CGO 2003},
keywords = {Buildings,Code standards,Computer architecture,Computer science,Design optimization,Emulation,Monitoring,Programming,Switches,Virtual manufacturing},
pages = {36--47},
title = {{Retargetable and reconfigurable software dynamic translation}},
year = {2003}
}
@inproceedings{Brummayer2009,
abstract = {Satisfiability Modulo Theories (SMT) is the problem of de- ciding satisfiability of a logical formula, expressed in a combination of first-order theories. We present the architecture and selected features of Boolector, which is an efficient SMT solver for the quantifier-free theories of bit-vectors and arrays. It uses term rewriting, bit-blasting to handle bit-vectors, and lemmas on demand for arrays.},
author = {Brummayer, Robert and Biere, Armin},
booktitle = {Lect. Notes Comput. Sci. (including Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics)},
doi = {10.1007/978-3-642-00768-2_16},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/https-pdfs.semanticscholar.org0a90478e373c13130d06a70cdb8ab27dedeecfc2.pdf.pdf:pdf},
isbn = {3642007678},
issn = {03029743},
pages = {174--177},
title = {{Boolector: An efficient SMT solver for bit-vectors and arrays}},
volume = {5505 LNCS},
year = {2009}
}
@article{Cha2012,
abstract = {In this paper we present MAYHEM, a new sys- tem for automatically finding exploitable bugs in binary (i.e., executable) programs. Every bug reported by MAYHEM is accompanied by a working shell-spawning exploit. The working exploits ensure soundness and that each bug report is security- critical and actionable. M AYHEM works on raw binary code without debugging information. To make exploit generation possible at the binary-level, MAYHEM addresses two major technical challenges: actively managing execution paths without exhausting memory, and reasoning about symbolic memory indices, where a load or a store address depends on user input. To this end, we propose two novel techniques: 1) hybrid symbolic execution for combining online and offline (concolic) execution to maximize the benefits of both techniques, and 2) index-based memory modeling, a technique that allows MAYHEM to efficiently reason about symbolic memory at the binary level. We used M AYHEM to find and demonstrate 29 exploitable vulnerabilities in both Linux and Windows programs, 2 of which were previously undocumented.},
author = {Cha, Sang Kil and Avgerinos, Thanassis and Rebert, Alexandre and Brumley, David},
doi = {10.1109/SP.2012.31},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/Cha et al.{\_}2012{\_}Unleashing Mayhem on Binary Code.pdf:pdf},
isbn = {9780769546810},
issn = {10816011},
journal = {Proc. - IEEE Symp. Secur. Priv.},
keywords = {exploit generation,hybrid execution,index-based memory modeling,symbolic memory},
pages = {380--394},
title = {{Unleashing Mayhem on binary code}},
year = {2012}
}
@article{Co2011,
abstract = {Because software provides much of the critical services for modern society, it is vitally important to provide methodologies and tools for building and deploying reliable software. While there have been many advances towards this goal, much research remains to be done. For example, a recent evaluation of five state-of-the-art C/C++ static analysis tools applied to a corpus of code containing common weaknesses revealed that 41{\%} of the potential vulnerabilities were detected by no tool. The problem of deploying resilient software is further complicated because modern software is often assembled from components from many sources. Consequently, it is difficult to know who built a particular component and what processes were used in its construction. Our research goal is to develop and demonstrate technology that provides comprehensive, automated techniques that allow end users to safely execute new software of uncertain provenance. This paper presents an overview of our vision for realizing these goals and outlines some of the challenging research problems that must be addressed to realize our vision. We call our vision PEASOUP and have begun implementing and evaluating these ideas.},
author = {Co, M and Davidson, J W and Hiser, J D and Knight, J C and Nguyen-Tuong, A and Cok, D and Gopan, D and Melski, D and Lee, W and Song, C and Bracewell, T and Hyde, D and Mastropietro, B},
doi = {10.1145/1988630.1988639},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/p43-co.pdf:pdf},
isbn = {9781450305815},
issn = {02705257},
journal = {Proc. - Int. Conf. Softw. Eng.},
keywords = {TechX,dynamic analysis,ex-,peasoup,ploit prevention,security testing,static analysis},
mendeley-tags = {TechX},
pages = {43--49},
title = {{PEASOUP: Preventing exploits against software of uncertain provenance}},
url = {http://www.scopus.com/inward/record.url?eid=2-s2.0-79959554765{\&}partnerID=40{\&}md5=45dae06cf2acb73b45cae69ea5d2d848},
year = {2011}
}
@misc{Brumley2016,
author = {Brumley, By David},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/Why CGC Matters to Me – ForAllSecure.pdf:pdf},
keywords = {Mayhem},
mendeley-tags = {Mayhem},
title = {{Why CGC Matters to Me}},
url = {https://blog.forallsecure.com/2016/07/26/why-cgc-matters-to-me/},
year = {2016}
}
@misc{Newsham2000,
abstract = {I know it has happened to you. It has happened to all of us, at one point or another. You're at a trendy dinner party, and amidst the frenzied voices of your companions you hear the words "format string attack." "Format string attack? What is a format string attack?" you ask. Afraid of having your ignorance exposed among your peers you decide instead to break an uncomfortable smile and nod in hopes of appearing to be in the-know. If all goes well, a few cocktails will pass and the conversation will move on, and no one will be the wiser. Well fear no more! This paper will cover everything you wanted to know about format string attacks but were afraid to ask!},
author = {Newsham, Timothy},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/Format string attack - OWASP.pdf:pdf},
pages = {8},
title = {{Format String Attacks}},
url = {https://www.owasp.org/index.php/Format{\_}string{\_}attack},
year = {2000}
}
@article{Li2014,
abstract = {The rise in efficiency of Satisfiability Modulo Theories (SMT) solvers has created numerous uses for them in software verification, program synthesis, functional programming, refinement types, etc. In all of these applications, SMT solvers are used for generating satisfying assignments (e.g., a witness for a bug) or proving unsatisfiability/validity(e.g., proving that a subtyping relation holds). We are often interested in finding not just an arbitrary satisfying assignment, but one that optimizes (minimizes/maximizes) certain criteria. For example, we might be interested in detecting program executions that maximize energy usage (performance bugs), or synthesizing short programs that do not make expensive API calls. Unfortunately, none of the available SMT solvers offer such optimization capabilities. In this paper, we present SYMBA, an efficient SMT-based optimization algorithm for objective functions in the theory of linear real arithmetic (LRA). Given a formula $\phi$ and an objective function t, SYMBA finds a satisfying assignment of $\phi$that maximizes the value of t. SYMBA utilizes efficient SMT solvers as black boxes. As a result, it is easy to implement and it directly benefits from future advances in SMT solvers. Moreover, SYMBA can optimize a set of objective functions, reusing information between them to speed up the analysis. We have implemented SYMBA and evaluated it on a large number of optimization benchmarks drawn from program analysis tasks. Our results indicate the power and efficiency of SYMBA in comparison with competing approaches, and highlight the importance of its multi-objective-function feature.},
author = {Li, Yi and Albarghouthi, Aws and Kincad, Z and Gurfinkel, Arie and Chechik, Marsha and Kincaid, Zachary and Gurfinkel, Arie and Chechik, Marsha},
doi = {10.1145/2535838.2535857},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/popl14.pdf:pdf},
isbn = {9781450325448},
issn = {15232867},
journal = {Proc. 41st ACM SIGPLAN-SIGACT Symp. Princ. Program. Lang. - POPL '14},
keywords = {generation,invariant,optimization,program analysis,satisfiability modulo theories,symbolic abstraction},
pages = {607--618},
title = {{Symbolic optimization with SMT solvers}},
url = {http://dl.acm.org/citation.cfm?id=2535857$\backslash$nhttp://dl.acm.org/citation.cfm?doid=2535838.2535857},
year = {2014}
}
@article{Cadar2008,
abstract = {We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achieve high coverage on a diverse set of complex and environmentally-intensive programs. We used KLEE to thoroughly check all 89 stand-alone programs in the GNU COREUTILS utility suite, which form the core user-level environment installed on millions of Unix systems, and arguably are the single most heavily tested set of open-source programs in existence. KLEE-generated tests achieve high line coverage - on average over 90{\%} per tool (median: over 94{\%}) - and significantly beat the coverage of the developers' own hand-written test suite. When we did the same for 75 equivalent tools in the BUSYBOX embedded system suite, results were even better, including 100{\%} coverage on 31 of them. We also used KLEE as a bug finding tool, applying it to 452 applications (over 430K total lines of code), where it found 56 serious bugs, including three in COREUTILS that had been missed for over 15 years. Finally, we used KLEE to crosscheck purportedly identical BUSYBOX and COREUTILS utilities, finding functional correctness errors and a myriad of inconsistencies.},
author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson R.},
doi = {10.1.1.142.9494},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/2008-12-OSDI-KLEE.pdf:pdf},
isbn = {978-1-931971-65-2},
issn = {{\textless}null{\textgreater}},
journal = {Proc. 8th USENIX Conf. Oper. Syst. Des. Implement.},
pages = {209--224},
title = {{KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs}},
url = {http://portal.acm.org/citation.cfm?id=1855756},
year = {2008}
}
@article{Blog2015,
author = {Blog, Bits},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/final 2 - shellphish/How We Fared in the Cyber Grand Challenge  Trail of Bits Blog-1.pdf:pdf},
number = {8},
title = {{How We Fared in the Cyber Grand Challenge}},
url = {http://blog.trailofbits.com/2015/07/15/how-we-fared-in-the-cyber-grand-challenge/},
year = {2015}
}
@article{Brumley2016a,
author = {Brumley, David and Davis, John and Goulden, Ryan and Nighswander, Tyler},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/final 2 - shellphish/Unleashing the Mayhem CRS - ForAllSecure-1.pdf:pdf},
title = {{got Unleashing the Mayhem CRS}},
year = {2016}
}
@article{Balakrishnan2008,
abstract = {Over the last seven years, we have developed static-analysis methods to recover a good approximation to the variables and dynamically allocated memory objects of a stripped executable, and to track the flow of values through them. The article presents the algorithms that we developed, explains how they are used to recover Intermediate Representations (IRs) from executables that are similar to the IRs that would be available if one started from source code, and describes their application in the context of program understanding and automated bug hunting. Unlike algorithms for analyzing executables that existed prior to our work, the ones presented in this article provide useful information about memory accesses, even in the absence of debugging information. The ideas described in the article are incorporated in a tool for analyzing Intel x86 executables, called CodeSurfer/x86. CodeSurfer/x86 builds a system dependence graph for the program, and provides a GUI for exploring the graph by (i) navigating its edges, and (ii) invoking operations, such as forward slicing, backward slicing, and chopping, to discover how parts of the program can impact other parts. To assess the usefulness of the IRs recovered by CodeSurfer/x86 in the context of automated bug hunting, we built a tool on top of CodeSurfer/x86, called Device-Driver Analyzer for x86 (DDA/x86), which analyzes device-driver executables for bugs. Without the benefit of either source code or symbol-table/debugging information, DDA/x86 was able to find known bugs (that had been discovered previously by source-code analysis tools), along with useful error traces, while having a low false-positive rate. DDA/x86 is the first known application of program analysis/verification techniques to industrial executables.},
archivePrefix = {arXiv},
arxivId = {arXiv:1011.1669v3},
author = {Balakrishnan, G. and Reps, T. and Melski, D. and Teitelbaum, T.},
doi = {10.1007/978-3-540-69149-5_22},
eprint = {arXiv:1011.1669v3},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/final 2 - shellphish/http-research.cs.wisc.eduwpispaperswysinwyx05.pdf.pdf:pdf},
isbn = {9783540691471},
issn = {03029743},
journal = {Lect. Notes Comput. Sci. (including Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics)},
pages = {202--213},
pmid = {25246403},
title = {{WYSINWYX: What you see is not what you execute}},
volume = {4171 LNCS},
year = {2008}
}
@article{Stephens2016,
abstract = {—Memory corruption vulnerabilities are an ever-present risk in software, which attackers can exploit to obtain private information or monetary gain. As products with access to sensitive data are becoming more prevalent, the number of potentially exploitable systems is also increasing, resulting in a greater need for automated software vetting tools. DARPA recently funded a competition, with millions of dollars in prize money, to further research of automated vulnerability finding and patching, showing the importance of research in this area. Current techniques for finding potential bugs include static, dynamic, and concolic analysis systems, which each have their own advantages and disadvantages. Systems designed to create inputs which trigger vulnerabilities typically only find shallow bugs and struggle to exercise deeper paths in executables. We present Driller, a hybrid vulnerability excavation tool which leverages fuzzing and selective concolic execution, in a complementary manner, to find deeper bugs. Inexpensive fuzzing is used to exercise compartments of an application, while concolic execution is used to generate inputs which satisfy the complex checks separating the compartments. By combining the strengths of the two techniques, we mitigate their weaknesses, avoiding the path explosion inherent in concolic analysis and the incomplete-ness of fuzzing. Driller uses selective concolic execution to explore only the paths deemed interesting by the instrumented fuzzer and to generate inputs for conditions that the fuzzer could not satisfy. We evaluate Driller on 126 applications released in the qualifying event of the DARPA Cyber Grand Challenge and show its efficacy by identifying the same number of vulnerabilities, in the same time, as the top-scoring team of the qualifying event.},
author = {Stephens, Nick and Grosen, John and Salls, Christopher and Dutcher, Andrew and Wang, Ruoyu and Corbetta, Jacopo and Shoshitaishvili, Yan and Kruegel, Christopher and Vigna, Giovanni},
doi = {10.14722/ndss.2016.23368},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf:pdf},
isbn = {189156241X},
journal = {Ndss},
keywords = {Mechanical Phish},
mendeley-tags = {Mechanical Phish},
number = {February},
pages = {21--24},
title = {{Driller: Augmenting Fuzzing Through Selective Symbolic Execution}},
year = {2016}
}
@article{Nguyen-Tuong2010,
abstract = {In this paper we determine analytically the effectiveness of dynamic artificial diversity, i.e., artificial diversity in which the subject of the diversity is re-randomized periodically and mechanically. We refer to a mechanism that implements dynamic diversity as a Metamorphic Shield since this mechanism applies metamorphosis to the system's attack surface to try to shield the system from certain attacks. Contrary to intuition, our analysis reveals that dynamic diversity appears to provide limited benefit except in special cases. In particular, it offers benefit for attacks that seek to leak information. We present a case study of the use of dynamic diversity applied to Instruction Set Randomization that is subject to an incremental attack on the key. {\&}copy; 2010 ACM.},
author = {Nguyen-Tuong, Anh and Wang, Andrew and Hiser, Jason D and Knight, John C and Davidson, Jack W},
doi = {10.1145/1842752.1842788},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/MetamorphicShield2.pdf:pdf},
isbn = {9781450301794},
journal = {ACM Int. Conf. Proceeding Ser.},
keywords = {Computer simulation;Software architecture;Technica},
pages = {170--174},
title = {{On the effectiveness of the metamorphic shield}},
url = {http://dx.doi.org/10.1145/1842752.1842788},
year = {2010}
}
@article{Miller2007,
author = {Miller, Charlie},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/final 2 - shellphish/https-fuzzinginfo.files.wordpress.com201205cmiller{\_}toorcon2007.pdf.pdf:pdf},
journal = {TorCon},
title = {{Fuzzing with Code Coverage By Example}},
year = {2007}
}
@article{Avgerinos2014,
abstract = {Att ackers commonly exploit buggy programs to break into computers. Security-critical bugs pave the way for attackers to install trojans, propagate worms, and use victim computers to send spam and launch denial-of-service attacks. A direct way, therefore, to make computers more secure is to find securitycritical bugs before they are exploited by attackers. Unfortunately, bugs are plentiful. For example, the Ubuntu Linux bug-management database listed more than 103,000 open bugs as of January 2013. Specific widely used programs (such as the Firefox Web browser and the Linux 3.x kernel) list 7,597 and 1,293 open bugs in their public bug trackers, respectively.a Other projects, including those that are closed-source, likely involve similar statistics. These are just the bugs we know; there is always the persistent threat of zero-day exploits, or attacks against previously unknown bugs. Among the thousands of known bugs, which should software developers fix first? Which are exploitable? {\textcopyright} 2014 ACM.},
author = {Avgerinos, T. and Cha, S.K. and Rebert, A. and Schwartz, E.J. and Woo, M. and Brumley, D.},
doi = {10.1145/2560217.2560219},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/p74-avgerinos.pdf:pdf},
isbn = {9781450302456},
issn = {00010782 15577317},
journal = {Commun. ACM},
keywords = {MayhemMayhem},
mendeley-tags = {MayhemMayhem},
number = {2},
pages = {74--84},
title = {{Automatic exploit generation}},
volume = {57},
year = {2014}
}
@article{Hiser2009,
abstract = {Memory errors continue to be a major source of software failure. To address this issue, we present MEDS (Memory Error Detection System), a system for detecting memory errors within binary executables. The system can detect buffer overflow, uninitialized data reads, double-free, and deallocated memory access errors and vulnerabilities. It works by using static analysis to prove memory accesses safe. If a memory access cannot be proven safe, MEDS falls back to run-time analysis. The system exceeds previous work with dramatic reductions in false positives, as well as covering all memory segments (stack, static, heap).},
author = {Hiser, Jason D. and Coleman, Clark L. and Co, Michele and Davidson, Jack W.},
doi = {10.1007/978-3-642-00199-4_14},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/2009ESSoS.pdf:pdf},
isbn = {364200198X},
issn = {03029743},
journal = {Lect. Notes Comput. Sci. (including Subser. Lect. Notes Artif. Intell. Lect. Notes Bioinformatics)},
pages = {164--179},
title = {{MEDS: The memory error detection system}},
volume = {5429 LNCS},
year = {2009}
}
@article{Wikipedia1996,
author = {Wikipedia},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/full/Taint checking - Wikipedia.pdf:pdf},
isbn = {0596002416},
pages = {7--8},
title = {{Taint checking}},
year = {1996}
}
@article{Shoshitaishvili2015,
abstract = {—Embedded devices have become ubiquitous, and they are used in a range of privacy-sensitive and security-critical applications. Most of these devices run proprietary software, and little documentation is available about the software's inner workings. In some cases, the cost of the hardware and protection mechanisms might make access to the devices themselves infeasible. Analyzing the software that is present in such environments is challenging, but necessary, if the risks associated with software bugs and vulnerabilities must be avoided. As a matter of fact, recent studies revealed the presence of backdoors in a number of embedded devices available on the market. In this paper, we present Firmalice, a binary analysis framework to support the analysis of firmware running on embedded devices. Firmalice builds on top of a symbolic execution engine, and techniques, such as program slicing, to increase its scalability. Furthermore, Firmalice utilizes a novel model of authentication bypass flaws, based on the attacker's ability to determine the required inputs to perform privileged operations. We evaluated Firmalice on the firmware of three commercially-available devices, and were able to detect authentication bypass backdoors in two of them. Additionally, Firmalice was able to determine that the backdoor in the third firmware sample was not exploitable by an attacker without knowledge of a set of unprivileged credentials.},
author = {Shoshitaishvili, Yan and Wang, Ruoyu and Hauser, Christophe and Kruegel, Christopher and Vigna, Giovanni},
doi = {10.14722/ndss.2015.23294},
file = {:Users/lordvader/Google Drive/PhD/Research Seminar Fall 2016 Papers/11{\_}1{\_}2.pdf:pdf},
isbn = {1-891562-38-X},
journal = {Proc. 2015 Netw. Distrib. Syst. Secur. Symp.},
keywords = {Mechanical Phish},
mendeley-tags = {Mechanical Phish},
number = {February},
pages = {8--11},
title = {{Firmalice - Automatic Detection of Authentication Bypass Vulnerabilities in Binary Firmware}},
url = {http://www.internetsociety.org/doc/firmalice-automatic-detection-authentication-bypass-vulnerabilities-binary-firmware},
year = {2015}
}
